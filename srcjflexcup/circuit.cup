import java_cup.runtime.*;
import nodes.nonterminals.*;
import nodes.terminals.*;
import nodes.nonterminals.*;
import nodes.expression.*;
import java.util.ArrayList;

/* Preliminaries to set up and use the scanner.  */
//init with {: scanner.init();              :};
//scan with {: return scanner.next_token(); :};

parser code{:
	Yylex lexer;

	public parser(Yylex lexer){
	    super(lexer);
	    this.lexer = lexer;
    }
    :};

 scan with {: return lexer.next_token(); :};


/* TERMINALI */

terminal String ID;
terminal String INT_CONST;
terminal String FLOAT_CONST;
terminal String STRING_CONST;

terminal INT, BOOL, FLOAT, STRING, SEMI, COMMA,  PROC, LPAR, RPAR,
         COLON, CORP,IF, THEN, ELIF, FI, ELSE, WHILE, DO, OD,
         READ, WRITE, ASSIGN, PLUS, MINUS, TIMES, DIV, EQ, NE, LT,
         LE, GT, GE, AND, OR, NOT, UMINUS, RETURN, FALSE,TRUE,VOID,NULL ;


/* NON TERMINALI */

nonterminal ArrayList<IdInitOP> IdListInit;
nonterminal ProgramOP Program;
nonterminal ArrayList<VarDeclOP> VarDeclList;
nonterminal ArrayList<ProcOP> ProcList;
nonterminal VarDeclOP VarDecl;
nonterminal TypeOP Type;
nonterminal WhileOP WhileStat;
nonterminal AssignOP AssignStat;
nonterminal CallProcOP CallProc;
nonterminal ExpressionOP Expr;
nonterminal ReadlnOP ReadlnStat;
nonterminal WriteOP WriteStat;
nonterminal StatOP Stat;
nonterminal IfOP IfStat;
nonterminal ArrayList<ElifOP> ElifList;
nonterminal ElifOP Elif;
nonterminal ElseOP Else;
nonterminal ProcOP Proc;
nonterminal ArrayList<ResultTypeOP> ResultTypeList;
nonterminal ReturnExprsOP ReturnExprs;
nonterminal ArrayList<ExpressionOP> ExprList;
nonterminal ArrayList<ParDeclOP> ParamDeclList;
nonterminal ParDeclOP ParDecl;
nonterminal ArrayList<Constant> IdList;
nonterminal ResultTypeOP ResultType;
nonterminal ArrayList<StatOP> StatList;


//ProcBodyOP BodyOP IdInitOP

//Precedenze e associatività
//precedence nonassoc ELSE;


precedence left OR;
precedence left AND;
precedence right NOT; //contrellare uso IF
precedence left LT,GT, LE, GE, EQ;
precedence left NE;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence right UMINUS;// era in dubbio verificare, molti mettono associatività a sinistra, ma è uguale al not lavora con quello di seguito.

/* Specifiche lessicali e grammaticali del linguaggio Toy*/

Program ::= VarDeclList:vl ProcList:pl {: RESULT = new ProgramOP(vl, pl) ;:};

VarDeclList ::= VarDecl:e VarDeclList:list {:((ArrayList<VarDeclOP>)list).add(e);
                                            RESULT = list;:}
	|  /* empty */ {:RESULT = new ArrayList<VarDeclOP>();:};//null

ProcList ::= Proc:e {:ArrayList<ProcOP> list = new ArrayList<ProcOP>(); list.add(e); RESULT = list;:}//NON TENGO LA LISTA, A CHI AGGIUNGO PROC??? TODO
	| ProcList:list Proc:e  {:((ArrayList<ProcOP>)list).add(e);  RESULT = list;:}; //invertita per ordine della lista quando viene inserita.

VarDecl ::= Type:type IdListInit:idList SEMI {: RESULT =  new VarDeclOP(type, idList);:};

Type ::= INT {:RESULT = new TypeOP("int");:}
    | BOOL   {:RESULT = new TypeOP("bool");:}
    | FLOAT  {:RESULT = new TypeOP("float");:}
    | STRING {:RESULT = new TypeOP("string");:};

IdListInit ::= ID:id {:ArrayList<IdInitOP> list = new ArrayList<IdInitOP>(); list.add(new IdInitOP(new Constant("ID",id))); RESULT = list;:}
	| IdListInit:list COMMA ID:id {: ((ArrayList<IdInitOP>)list).add(new IdInitOP(new Constant("ID",id))); RESULT = list;:}
	| ID:id ASSIGN Expr:e {:ArrayList<IdInitOP> list = new ArrayList<IdInitOP>(); list.add(new IdInitOP(new AssignOP(new Constant("ID",id),e))); RESULT = list;:}
	| IdListInit:list COMMA ID:id ASSIGN Expr:e {: ((ArrayList<IdInitOP>)list).add(new IdInitOP(new AssignOP(new Constant("ID",id),e))); RESULT = list;:};

Proc ::= PROC ID:id LPAR ParamDeclList:pl RPAR ResultTypeList:rtl COLON
		VarDeclList:vdl StatList:sl RETURN ReturnExprs:re CORP SEMI {: RESULT= new ProcOP(new Constant("ID",id),pl,rtl,new ProcBodyOP(vdl,sl,re));:}
	| PROC ID:id LPAR RPAR ResultTypeList:rtl COLON
		VarDeclList:vdl StatList:sl RETURN ReturnExprs:re CORP SEMI {: RESULT= new ProcOP(new Constant("ID",id),rtl,new ProcBodyOP(vdl,sl,re));:}
	| PROC ID:id LPAR ParamDeclList:pl RPAR ResultTypeList:rtl COLON
      	VarDeclList:vdl RETURN ReturnExprs:re CORP SEMI {: RESULT= new ProcOP(new Constant("ID",id),pl,rtl,new ProcBodyOP(vdl,re));:}
    | PROC ID:id LPAR RPAR ResultTypeList:rtl COLON
      	VarDeclList:vdl RETURN ReturnExprs:re CORP SEMI {: RESULT= new ProcOP(new Constant("ID",id),rtl,new ProcBodyOP(vdl,re));:};

ResultTypeList ::= ResultType:r {:ArrayList<ResultTypeOP> list = new ArrayList<ResultTypeOP>(); list.add(r); RESULT = list;:}
	| ResultTypeList:list COMMA ResultType:r {:((ArrayList<ResultTypeOP>)list).add(r); RESULT = list;:};  // modificata per invertire inserimento nella lista.

ReturnExprs::=  ExprList:el {:RESULT = new ReturnExprsOP(el);:}
	| /* empty */ {:RESULT = new ReturnExprsOP(new Constant("VOID"));:};

ExprList ::= Expr:e {:ArrayList<ExpressionOP> list = new ArrayList<ExpressionOP>(); list.add(e); RESULT = list;:}
	| ExprList:list COMMA Expr:e   {:((ArrayList<ExpressionOP>)list).add(e); RESULT = list;:};  //modifica per ordine

ParamDeclList ::= ParDecl:p {:ArrayList<ParDeclOP> list = new ArrayList<ParDeclOP>(); list.add(p); RESULT = list;:}
    | ParamDeclList:list SEMI ParDecl:p {: ((ArrayList<ParDeclOP>)list).add(p); RESULT = list;:};

ParDecl ::= Type:t IdList:list {:RESULT = new ParDeclOP(t,list);:};

IdList ::= ID:id {:ArrayList<Constant> list = new ArrayList<Constant>(); list.add(new Constant("ID",id)); RESULT = list;:}
    | IdList:list COMMA ID:id {:((ArrayList<Constant>)list).add(new Constant("ID",id)); RESULT = list;:};

ResultType ::= Type:t {: RESULT = new ResultTypeOP(t);:}
    | VOID {:RESULT = new ResultTypeOP(new Constant("VOID"));:};

StatList ::= Stat:s  {:ArrayList<StatOP> list = new ArrayList<StatOP>(); list.add(s); RESULT = list;:}
    | StatList:list Stat:s{: ((ArrayList<StatOP>)list).add(s); RESULT = list;:};        //Invertita stat statlist per ordine di inserimento.

Stat ::= IfStat:i SEMI {:RESULT =new StatOP(i);:}
	| WhileStat:w SEMI {:RESULT =new StatOP(w);:}
	| ReadlnStat:re SEMI {:RESULT =new StatOP(re);:}
	| WriteStat:wr SEMI {:RESULT =new StatOP(wr);:}
	| AssignStat:a SEMI {:RESULT =new StatOP(a);:}
	| CallProc:c SEMI {:RESULT =new StatOP(c);:};
	//| /* empty */; //TOLTO DEL PROF

IfStat ::= IF Expr:e THEN StatList:sl ElifList:el Else:els FI {:RESULT = new IfOP(e,new BodyOP(sl),el,els);:};

ElifList ::= /* empty */ {:RESULT = new ArrayList<ElifOP>();:}
	| Elif:e ElifList:list {:((ArrayList<ElifOP>)list).add(e); RESULT = list;:};

Elif ::= ELIF Expr:e THEN StatList:sl {:RESULT = new ElifOP(e,new BodyOP(sl));:};

Else ::= /* empty */ {:RESULT = null;:}
    | ELSE StatList:sl {:RESULT = new ElseOP(new BodyOP(sl));:};

WhileStat ::= WHILE StatList:sl1 RETURN Expr:e DO StatList:sl2 OD {:RESULT = new WhileOP(new BodyOP(sl1),e,new BodyOP(sl2));:}
	| WHILE Expr:e DO StatList:sl OD {:RESULT = new WhileOP(e,new BodyOP(sl));:};

ReadlnStat ::= READ LPAR IdList:list RPAR {:RESULT = new ReadlnOP(list);:};

WriteStat ::=  WRITE LPAR ExprList:list RPAR {:RESULT = new WriteOP(list);:};

AssignStat ::= IdList:idList ASSIGN  ExprList:eList {:RESULT = new AssignOP(idList,eList);:};

CallProc ::= ID:e1 LPAR ExprList:list RPAR {:RESULT = new CallProcOP(new Constant("ID",e1),new ParamOP(list)); :}//modifica aggiunta paramOP
	| ID:e1 LPAR RPAR {:RESULT = new CallProcOP(new Constant("ID",e1)); :};

Expr ::= NULL                   {:RESULT =  new Constant("NULL",null);:}
	| TRUE                      {:RESULT =  new Constant("bool","true");:}
	| FALSE                     {:RESULT =  new Constant("bool","false");:}
	| INT_CONST:e               {:RESULT = new Constant("int",e);:}
	| FLOAT_CONST:e             {:RESULT = new Constant("float",e);:}
	| STRING_CONST:e            {:RESULT = new Constant("string",e);:}
	| ID:e                      {:RESULT = new Constant("ID",e);:}
    | CallProc:c                {:RESULT = c;:}
	| Expr:e1  PLUS Expr:e2     {:RESULT = new PlusOP(e1,e2 );:}
	| Expr:e1  MINUS Expr:e2    {:RESULT =  new MinusOP(e1,e2 );:}
	| Expr:e1  TIMES Expr:e2    {:RESULT =  new TimesOP(e1,e2 );:}
	| Expr:e1  DIV Expr:e2      {:RESULT =  new DivOP(e1,e2 );:}
	| Expr:e1  AND Expr:e2      {:RESULT =  new AndOP(e1,e2 );:}
	| Expr:e1  OR Expr:e2       {:RESULT =  new OrOP(e1,e2 );:}
	| Expr:e1  GT Expr:e2       {:RESULT =  new GtOP(e1,e2 );:}
	| Expr:e1  GE Expr:e2       {:RESULT =  new GeOP(e1,e2 );:}
	| Expr:e1  LT Expr:e2       {:RESULT =  new LtOP(e1,e2 );:}
	| Expr:e1  LE Expr:e2       {:RESULT =  new LeOP(e1,e2 );:}
	| Expr:e1  EQ Expr:e2       {:RESULT =  new EqOP(e1,e2 );:}
	| Expr:e1  NE Expr:e2       {:RESULT =  new NeOP(e1,e2 );:}
	| MINUS Expr:e              {:RESULT =  new UminusOP(e);:} %prec UMINUS
	| NOT Expr:e                {:RESULT =  new NotOP(e);:};