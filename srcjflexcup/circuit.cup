import java_cup.runtime.*;

/* Preliminaries to set up and use the scanner.  */
//init with {: scanner.init();              :};
//scan with {: return scanner.next_token(); :};

/* TERMINALI */
terminal SEMI, COMMA, ID, INT, STRING, FLOAT, BOOL;
terminal PROC, LPAR, RPAR, COLON, CORP, VOID, IF, THEN, ELIF, FI, ELSE, WHILE, DO, OD;
terminal READ, WRITE, ASSIGN, PLUS, MINUS, TIMES, DIV, EQ, NE, LT, LE, GT, GE;
terminal AND, OR, NOT, NULL, TRUE, FALSE,RETURN, UMINUS;
terminal Integer INT_CONST;
terminal Float FLOAT_CONST;
terminal String STRING_CONST;

/* NON TERMINALI */

nonterminal ProgramOP Program;
nonterminal ArrayList<VarDecOP> VarDeclList;
nonterminal ArrayList<ProcListOP> ProcList;
nonterminal VarDecOP VarDecl;
nonterminal TypeOP Type;
nonterminal ArrayList<ID> IdListInit;
nonterminal ProcOP Proc;
nonterminal ArrayList<ResultTypeOP> ResultTypeList;
nonterminal ReturnExpreOP ReturnExprs;
nonterminal ArrayList<ExpressionOP> ExprList;
nonterminal ArrayList<ParDeclOP> ParamDeclList;
nonterminal ParDeclOP ParDecl;
nonterminal ArrayList<ID> IdList;
nonterminal ArrayList<ResultTypeOP> ResultType;
nonterminal ArrayList<StatOP> StatList;
nonterminal StatOP Stat;
nonterminal IfStatOP IfStat;
nonterminal ArrayList<ElifOP> ElifList;
nonterminal ElifOP Elif;
nonterminal ElseOP Else;
nonterminal WhileOP WhileStat;
nonterminal ReadlnOP ReadlnStat;
nonterminal WriteOP WriteStat;
nonterminal AssignOP AssignStat;
nonterminal CallProcOP CallProc;
nonterminal ExpressionOP Expr;

//Precedenze e associatività

precedence left LT,GT, LE, GE, EQ;
precedence left NE;
precedence right NOT;
precedence left OR;
precedence left AND;


precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence left UMINUS;

/* Specifiche lessicali e grammaticali del linguaggio Toy*/
Program ::= VarDeclList:vl ProcList:pl {:RESULT= new ProgramOP(vl,pl);:};

VarDeclList ::= /* empty */     {:RESULT= new ArrayList<VarDecOP>();:}
    | VarDecl:e VarDeclList:list       {:RESULT= ((ArrayList<VarDecOP>)list).add(e);:};

ProcList ::= Proc:e    {:RESULT= new ArrayList<ProcListOP>().add(e);:}  //non tengo la lista a chi aggiungo proc
    | Proc:e ProcList:list         {:RESULT= ((ArrayList<ProcListOP>)list).add(e);:};

VarDecl ::= Type:type IdListInit:idlist SEMI    {:RESULT= new VarDecOP(type, idlist);:};

Type ::= INT    {:RESULT= new TypeOP("int");:}
    | BOOL      {:RESULT= new TypeOP("bool");:}
    | FLOAT     {:RESULT= new TypeOP("float");:}
    | STRING    {:RESULT= new TypeOP("string");:};

IdListInit ::= ID:e           {:RESULT= new ArrayList<ID>().add(new ID(e));:}
    | IdListInit:list COMMA ID:e       {:RESULT=((ArrayList<ID>)list).add(new ID(e));:}
    | ID:id ASSIGN Expr:e              {:RESULT= new ArrayList<ID>().add(new AssingOP(new ID(id),e))  ;:}
    | IdListInit:list COMMA ID:id ASSIGN Expr:e  {:RESULT= ((ArrayList<ID>)list).add(new AssignOP(new ID(id),e)) ;:}   ;

Proc ::= PROC ID:id LPAR ParamDeclList:pl RPAR ResultTypeList:rtl COLON
		VarDeclList:vdl StatList:sl RETURN ReturnExprs:re CORP SEMI     {:RESULT= new ProcOP(new ID(id),pl,rtl, new ProcBodyOP(vdl,sl,re)) ;:}
	|PROC ID:id LPAR ParamDeclList:pl RPAR ResultTypeList:rtl COLON
		VarDeclList:vdl RETURN ReturnExprs:re CORP SEMI            {:RESULT= new ProcOP(new ID(id),pl,rtl, new ProcBodyOP(vdl,re)) ;:}
	| PROC ID:id LPAR RPAR ResultTypeList:rtl COLON
		VarDeclList:vdl StatList:sl RETURN ReturnExprs:re CORP SEMI   {:RESULT= new ProcOP(new ID(id),rtl, new ProcBodyOP(vdl,re)) ;:}
	| PROC ID:id LPAR RPAR ResultTypeList:rtl COLON
		VarDeclList:vdl RETURN ReturnExprs:re CORP SEMI        {:RESULT= new ProcOP(new ID(id),rtl, new ProcBodyOP(vdl,re)) ;:};

ResultTypeList ::= ResultType:r               {:RESULT= new ArrayList<ResultTypeOP>().add(r) ;:}
    | ResultType:r COMMA ResultTypeList:list  {:RESULT= ((Arraylist<ResutlType>)list).add(r);:};

ReturnExprs::= ExprList:list        {:RESULT= new ReturnExpreOP(list);:}
    | /* empty */                  {:RESUTL= null;:};

ExprList::= Expr:e          {:RESULT = new ArrayList<ExpressionOP>().add(e);:}
    | Expr:e COMMA ExprList:list  {:RESULT= ((Arraylist<ExpressionOP>)list).add(e);:};

ParamDeclList ::= ParDecl:p     {:RESULT= new ArrayList<ParDeclOP>().add(p);:}
    | ParamDeclList:list SEMI ParDecl:p     {:RESULT=((ArrayList<ParDeclOP>)list).add(p);:};

ParDecl ::= Type:t IdList:list      {:RESULT=new ParDeclOP(t,list);:};

IdList ::= ID:id    {:RESULT= new ArrayList<ID>().add(new ID(id));:}
    | IdList:list COMMA ID:id   {:RESULT= ((ArrayList<ID>)list).add(new ID(id)) ;:};

ResultType ::= Type:t       {:RESULT= new TypeOP(t.toString());:}
    | VOID      {:RESULT= new TypeOP("void");:};
//new VOID()

/* empty
StatList ::= Stat
    | Stat StatList;

Stat ::= IfStat SEMI
    | WhileStat SEMI
    | ReadlnStat SEMI
    | WriteStat SEMI
    | AssignStat SEMI
    | CallProc SEMI
    | /* empty */


StatList ::= Stat:s     {:RESULT=new ArrayList<StatOP>().add(s);:}
    | Stat:s StatList:list  {:RESULT= ((ArrayList<StatOP>)list).add(s);:};

Stat ::= IfStat:i SEMI    {:RESULT=new StatOP(i);:}
	| WhileStat:w SEMI      {:RESULT=new StatOP(w);:}
	| ReadlnStat:re SEMI    {:RESULT=new StatOP(re);:}
	| WriteStat:wr SEMI     {:RESULT=new StatOP(wr);:}
	| AssignStat:a SEMI     {:RESULT=new StatOP(a);:}
	| CallProc:c SEMI      {:RESULT=new StatOP(c);:};


IfStat ::= IF Expr:e THEN StatList:sl ElifList:el Else:els FI {:RESULT= new IfStatOP(e,new BodyOP(sl),el,els) ;:}  ;

ElifList ::= /* empty */    {:RESULT=new ArrayList<ElifOP>();:}
    | Elif:e ElifList:list        {:RESULT= ((ArrayList<ElifOP>)list).add(e);:};

Elif ::= ELIF Expr:e THEN StatList:sl    {:RESULT= new ElifOP(e,new BodyOP(sl));:};

Else ::= /* empty */    {:RESULT=null;:}
    | ELSE StatList:sl     {:RESULT=new ElseOP(new BodyOP(sl));:};

//modificata
/* WhileStat ::= WHILE StatList Expr DO StatList OD
    | WHILE Expr DO StatList OD;            perchè statlist può andare in stat che va in empty*/

WhileStat ::= WHILE StatList:sl1 RETURN Expr:e DO StatList:sl2 OD   {:RESULT=new WhileOP(new BodyOP(sl1),e,new BodyOP(sl2));:}
	| WHILE Expr:e DO StatList:sl OD     {:RESULT=new WhileOP(e,new BodyOP(sl));:};

ReadlnStat ::= READ LPAR IdList:list RPAR  {:RESULT=new ReadlnOP(list);:};

WriteStat ::= WRITE LPAR ExprList:list RPAR {:RESULT=new WriteOP(list);:};

AssignStat ::= IdList:idList ASSIGN ExprList:elist  {:RESULT=new AssignOP(idList,elist);:};

CallProc ::= ID:id LPAR ExprList:elist RPAR     {:RESULT=new CallProcOP(new ID(e1), elist);:}
    | ID:id LPAR RPAR      {:RESULT= new CallProcOP(new ID(id));:};

Expr ::= NULL       {: RESULT =new NULL(); :}
    | TRUE          {: RESULT =new TRUE(); :}
    | FALSE         {: RESULT =new FALSE(); :}
    | INT_CONST:e     {: RESULT =new INT_CONST(e); :}
    | FLOAT_CONST:e   {: RESULT =new FLOAT_CONST(e); :}
    | STRING_CONST:e  {: RESULT =new STRING_CONST(e); :}
    | ID:id             {: RESULT =new ID(id); :}
    | CallProc:c        {:RESULT=c;:}
    | Expr:e1 PLUS Expr:e2      {: RESULT =new PlusOP(e1,e2); :}
    | Expr:e1 MINUS Expr:e2     {: RESULT =new MinusOP(e1,e2); :}
    | Expr:e1 TIMES Expr:e2     {: RESULT =new TimesOP(e1,e2); :}
    | Expr:e1 DIV Expr:e2       {: RESULT =new DivOP(e1,e2); :}
    | Expr:e1 AND Expr:e2       {: RESULT =new AndOP(e1,e2); :}
    | Expr:e1 OR Expr:e2        {: RESULT =new OrOP(e1,e2); :}
    | Expr:e1 GT Expr:e2        {: RESULT =new GtOP(e1,e2); :}
    | Expr:e1 GE Expr:e2        {: RESULT =new GeOP(e1,e2); :}
    | Expr:e1 LT Expr:e2        {: RESULT =new LtOP(e1,e2); :}
    | Expr:e1 LE Expr:e2        {: RESULT =new LeOP(e1,e2); :}
    | Expr:e1 EQ Expr:e2        {: RESULT =new EqOP(e1,e2); :}
    | Expr:e1 NE Expr:e2        {: RESULT =new NeOP(e1,e2); :}
    | MINUS Expr:e             {: RESULT = new UminusOP(e); :} %prec UMINUS
    | NOT Expr:e               {: RESULT =new NotOP(e); :}
    ;


